
// The top-level Verilog file for eecs301_lab2
// This code was initially generated by Terasic System Builder

module eecs301_lab2(

         //////////// ADC //////////
         output ADC_CONVST,
         output ADC_DIN,
         input ADC_DOUT,
         output ADC_SCLK,

         //////////// CLOCK //////////
         input CLOCK_50,
         input CLOCK2_50,
         input CLOCK3_50,
         input CLOCK4_50,

         //////////// SEG7 //////////
         output [ 6: 0 ] HEX0,
         output [ 6: 0 ] HEX1,
         output [ 6: 0 ] HEX2,
         output [ 6: 0 ] HEX3,
         output [ 6: 0 ] HEX4,
         output [ 6: 0 ] HEX5,

         //////////// KEY //////////
         input [ 3: 0 ] KEY,

         //////////// LED //////////
         output [ 9: 0 ] LEDR,

         //////////// SW //////////
         input [ 9: 0 ] SW,

         //////////// VGA //////////
         output [ 7: 0 ] VGA_B,
         output VGA_BLANK_N,
         output VGA_CLK,
         output [ 7: 0 ] VGA_G,
         output VGA_HS,
         output [ 7: 0 ] VGA_R,
         output VGA_SYNC_N,
         output VGA_VS,

         //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_0,

         //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_1
       );

//=======================================================
//  REG/WIRE declarations
//=======================================================
// Signals for connection to motor
wire [1:0] motor_in;
wire motor_en;
wire encoder_a, encoder_b;
wire button_clock;
wire signed [7:0] goal_speed;
wire [7:0] gain;
wire [7:0] duty_cycle;
wire signed [7:0] measured_speed;
wire pwm_clock;

//=======================================================
//  Structural coding
//=======================================================

// Zero hex displays
assign HEX0[6:0] = 7'b1111111;
assign HEX1[6:0] = 7'b1111111;
assign HEX2[6:0] = 7'b1111111;
assign HEX3[6:0] = 7'b1111111;
assign HEX4[6:0] = 7'b1111111;
assign HEX5[6:0] = 7'b1111111;

// Connect the motor signals to the GPIO
// Bit 0 is clockwise, 1 is counterclockwise
assign {GPIO_0[3], GPIO_0[1]} = motor_in;
assign GPIO_0[4] = motor_en;
assign {encoder_b, encoder_a} = GPIO_0[7:6];

// Switch 0 controls enable
assign motor_en = SW[0];

// Switches 9-2 determine gain
assign gain = SW[9:2];

button_clock_generator(CLOCK_50, 0, button_clock); // Generates the clock for the goal speed buttons
goal(button_clock, ~KEY[0], ~KEY[1], ~KEY[2], goal_speed);
motor_decoder(CLOCK_50, encoder_a, encoder_b, measured_speed);
duty_cycle_calculator(goal_speed, measured_speed, gain, duty_cycle);
pwm_clock_generator(CLOCK_50, 0, pwm_clock); // Generates 24.5 KHz clock for PWM
pwm_gen(pwm_clock, duty_cycle, motor_in);

endmodule