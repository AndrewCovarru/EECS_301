
// The top-level Verilog file for eecs301_lab6
// This code was initially generated by Terasic System Builder

module eecs301_lab6(

         //////////// ADC //////////
         output ADC_CONVST,
         output ADC_DIN,
         input ADC_DOUT,
         output ADC_SCLK,

         //////////// CLOCK //////////
         input CLOCK_50,
         input CLOCK2_50,
         input CLOCK3_50,
         input CLOCK4_50,

         //////////// SEG7 //////////
         output [ 6: 0 ] HEX0,
         output [ 6: 0 ] HEX1,
         output [ 6: 0 ] HEX2,
         output [ 6: 0 ] HEX3,
         output [ 6: 0 ] HEX4,
         output [ 6: 0 ] HEX5,

         //////////// KEY //////////
         input [ 3: 0 ] KEY,

         //////////// LED //////////
         output [ 9: 0 ] LEDR,

         //////////// SW //////////
         input [ 9: 0 ] SW,

         //////////// VGA //////////
         output [ 7: 0 ] VGA_B,
         output VGA_BLANK_N,
         output VGA_CLK,
         output [ 7: 0 ] VGA_G,
         output VGA_HS,
         output [ 7: 0 ] VGA_R,
         output VGA_SYNC_N,
         output VGA_VS,

         //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_0,

         //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
         inout [ 35: 0 ] GPIO_1
       );

//=======================================================
//  REG/WIRE declarations
//=======================================================

// Wire for PLL
wire pll_locked;

// Wires for display
wire [27:0] video_bus;
wire [7:0] disp_red, disp_green, disp_blue;
wire disp_clock, disp_en, disp_hsync, disp_vsync;

// Wires for video position synchronization
wire [9:0] h_pos, v_pos;
wire valid_draw, v_blank;

// Wires to be used with switches
wire video_en;
wire count_set;
wire min_hr;

// Wire for second clock
wire clk1mhz;
wire second_clock;

// Wires for the timer
wire alarm;
wire timer_reset;
wire up;
wire down;
wire [23:0] bcd_digits;

// Output assignments for the display
assign {GPIO_1[31:19], GPIO_1[17], GPIO_1[15:3], GPIO_1[1]} = video_bus;
assign video_bus = {disp_vsync, disp_hsync, disp_en, disp_clock, disp_blue, disp_green, disp_red};
assign disp_en = pll_locked;

// Input assignments for switches
assign video_en = SW[9];
assign count_set = SW[0];
assign min_hr = SW[1];

assign timer_reset = ~KEY[0];
assign up = ~KEY[3];
assign down = ~KEY[2];

// DAC code
assign GPIO_0[9] = DAC_in;
assign GPIO_0[10] = DAC_sync;
assign GPIO_0[11] = 1'b0;  
assign GPIO_0[8] = DAC_clk;
assign DAC_clk = CLOCK_50;

//=======================================================
//  Structural coding
//=======================================================

pll freq_gen(CLOCK_50, 1'b0, disp_clock, clk1mhz, pll_locked);
second_clock_gen second_gen(clk1mhz, second_clock);
video_position_sync sync_display(disp_clock, pll_locked, valid_draw, v_blank, h_pos, v_pos, disp_hsync, disp_vsync);
timer timer_main(second_clock, count_set, min_hr, timer_reset, up, down, bcd_digits, alarm);
video_controller controller(disp_clock, video_en, count_set, bcd_digits, alarm, valid_draw, v_blank, h_pos, v_pos, disp_red, disp_green, disp_blue);	

sync_clk sync_enable (					
				.clk(CLOCK_50),									
				.in(alarm),										
				.out(enable_switch)								
			);														
																	
sync_clk sync_change (			
				.clk(CLOCK_50),								
				.in(~KEY[1]),										
				.out(change_switch)								
			);														 
																	
sync_clk sync_a (						
				.clk(CLOCK_50),									
				.in(GPIO_0[6]),									 
				.out(encoder_a)									 
			);												
																		
sync_clk sync_b (				
				.clk(CLOCK_50),									 
				.in(GPIO_0[7]),									
				.out(encoder_b)									 
			);		

values set_v (
				.clk(CLOCK_50), 
				.reset_button(reset_button), 
				.A(encoder_a), 
				.B(encoder_b), 
				.change_switch(change_switch), 
				.amp_out(amp_out), 
				.freq_out(freq_out)
			);

slow_down cs (
				.clk(CLOCK_50),
				.out(pulse),
				.counter_internal_byte()
			);

// NCO generates sine wave
NCO_Lab3 u0 (
				.clk       (CLOCK_50),
				.clken     (pulse),     
				.phi_inc_i (freq_out),
				.fsin_o    (orig_sine),
				.out_valid (out_valid),
				.reset_n   (1'b1)
			);
			
// multiply the amplitude to the sine wave
mult gm (
				.clk(CLOCK_50),
				.sine(orig_sine), 
				.gain(amp_out), 
				.gain_sine(gain_sine)
			);

// sends the sine wave data to the DAC 
shiftreg dd ( 
				.clk(CLOCK_50),
				.sine_data(gain_sine),
				.dac_out(DAC_in),
				.sync(DAC_sync)
			);	

endmodule
